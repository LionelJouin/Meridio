package watcher

import (
	"context"
	"fmt"
	"time"

	"github.com/nordix/meridio/pkg/retry"
	"github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/watch"
)

// Monitor -
// Watches a particular kubernetes object through k8s API
type Monitor struct {
	name      string
	namespace string
	object    WatchObject
	watcher   watch.Interface
	handler   WatchEventHandler
}

// NewObjectMonitor -
// param name: name of the k8s object to monitor
// param namespace: namespace of the object to monitor
// param create: func that creates the specific type of k8s object for monitoring purposes (e.g. v1.SecretInterface)
// param handler: handles watch events generated by the monitor
func NewObjectMonitor(name string, namespace string, handler WatchEventHandler, create CreateWatchObject) (*Monitor, error) {
	object, err := create(namespace)
	if err != nil {
		return nil, fmt.Errorf("init object %v (namespace=%v) error: %v", name, namespace, err)
	}

	monitor := &Monitor{
		name:      name,
		namespace: namespace,
		handler:   handler,
		object:    object,
	}
	return monitor, nil
}

// Start -
// Starts monitoring the object, and relays events to handler
// Note: blocks caller
func (om *Monitor) Start(ctx context.Context) {
	err := retry.Do(func() error {
		logrus.Debugf("Monitor object %v (namespace=%v)", om.name, om.namespace)
		var err error
		objectMeta := metav1.ObjectMeta{Name: om.name, Namespace: om.namespace}
		om.watcher, err = om.object.Watch(ctx, metav1.SingleObject(objectMeta))
		if err != nil {
			logrus.Errorf("Unable to watch object %v (namespace=%v); %v", om.name, om.namespace, err)
			return err
		}
		om.watchEvent(ctx, om.watcher.ResultChan())
		return nil
	}, retry.WithContext(ctx),
		retry.WithDelay(500*time.Millisecond),
		retry.WithErrorIngnored())
	if err != nil {
		logrus.Errorf("Object monitor error: %v", err)
	}
}

// Stop -
// Stops the object monitor, and signals event handler
func (om *Monitor) Stop(ctx context.Context) {
	logrus.Debugf("Stop object monitor %v (namespace=%v)", om.name, om.namespace)
	if om.watcher != nil {
		om.watcher.Stop()
	}
	om.handler.End(ctx, om.namespace, om.name)
}

func (om *Monitor) watchEvent(ctx context.Context, eventChannel <-chan watch.Event) {
	for {
		select {
		case event, open := <-eventChannel:
			if open {
				// inform watch event handler
				om.handler.Handle(ctx, &event)
			} else {
				logrus.Debugf("Event channel closed %v (namespace=%v)", om.name, om.namespace)
				return
			}
		case <-ctx.Done():
		}
	}
}
